// This code was generated by robots, do not modify
// This is an inline file for use with @file

#include "reflection_gen.h"

@struct_metadata{
// @struct_name ----------------------------
TypeMetadata* meta_@struct_name = new TypeMetadata();
template<>
struct Reflector<@struct_name>{
   static TypeMetadata const* type() { return meta_@struct_name; }
};

}

void @file{}_reflectionStartup_generated(){
   // this should be called automatically by reflectionStartup_generated()
   @enum_metadata_init{
   {
      auto& enumName = meta_@enum_name;
      enumName->name = intern("@enum_name");
      enumName->size = sizeof(@enum_name);
      enumName->variety = TypeVariety_Enum;
      @enum_flag{enumName->enumFlags |= @flag;
      }

      @enum_metadata_entry_init{
      {
         EnumEntryMetadata entry;
         entry.name = intern("@entry_name");
         entry.value = @entry_name;
         enumName->enumEntries.push_back(entry);
      }

      }
   }

   }
   @struct_metadata_init{
   {
      auto& structName = meta_@struct_name;
      structName->name = intern("@struct_name");
      structName->size = sizeof(@struct_name);
      structName->variety = TypeVariety_Struct;

      structName->funcs.create = [](void* data) {new (data) @struct_name;};
      structName->funcs.destroy = [](void* data) {((@struct_name*)data)->~@struct_name{}(); };

      @struct_metadata_member_init{
      {
         StructMemberMetadata member;
         member.name = intern("@member_name");
         member.offset = offsetof(@struct_name, @member_name);
         member.type = reflect<@member_type>();
         member.customUI = customUIRenderer<@member_type>();
         @struct_flag{member.flags |= @flag;
         }@struct_static{member.staticArraySize = @size;
         }@struct_ui{member.ui.@key = (float)@value;
         }
         @struct_reference{member.reference = true;
         member.referenceOwnerType = reflect<std::unordered_map<Symbol*, @member_type>>();
         member.referenceOwner = (void*)@reference_owner;
         member.referenceKeyMember = intern(@reference_key);
         }

         structName->structMembers.push_back(member);
      }

      }
   }

   }   
}