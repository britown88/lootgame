// This code was generated by robots, do not modify
// This is an inline file for use with app

#include "reflection_gen.h"


// MyEnum ----------------------------
TypeMetadata* meta_MyEnum = new TypeMetadata();
template<>
struct Reflector<MyEnum>{
   static TypeMetadata const* type() { return meta_MyEnum; }
};


// MyBitfield_ ----------------------------
TypeMetadata* meta_MyBitfield_ = new TypeMetadata();
template<>
struct Reflector<MyBitfield_>{
   static TypeMetadata const* type() { return meta_MyBitfield_; }
};


// MyStruct ----------------------------
TypeMetadata* meta_MyStruct = new TypeMetadata();
template<>
struct Reflector<MyStruct>{
   static TypeMetadata const* type() { return meta_MyStruct; }
};



void app_reflectionStartup_generated(){
   // this should be called automatically by reflectionStartup_generated()
   
   {
      auto& enumName = meta_MyEnum;
      enumName->name = intern("MyEnum");
      enumName->size = sizeof(MyEnum);
      enumName->variety = TypeVariety_Enum;
      

      
      {
         EnumEntryMetadata entry;
         entry.name = intern("MyEnum_A");
         entry.value = MyEnum_A;
         enumName->enumEntries.push_back(entry);
      }

      
      {
         EnumEntryMetadata entry;
         entry.name = intern("MyEnum_B");
         entry.value = MyEnum_B;
         enumName->enumEntries.push_back(entry);
      }

      
      {
         EnumEntryMetadata entry;
         entry.name = intern("MyEnum_C");
         entry.value = MyEnum_C;
         enumName->enumEntries.push_back(entry);
      }

      
      {
         EnumEntryMetadata entry;
         entry.name = intern("MyEnum_D");
         entry.value = MyEnum_D;
         enumName->enumEntries.push_back(entry);
      }

      
      {
         EnumEntryMetadata entry;
         entry.name = intern("MyEnum_E");
         entry.value = MyEnum_E;
         enumName->enumEntries.push_back(entry);
      }

      
      {
         EnumEntryMetadata entry;
         entry.name = intern("MyEnum_F");
         entry.value = MyEnum_F;
         enumName->enumEntries.push_back(entry);
      }

      
   }

   
   {
      auto& enumName = meta_MyBitfield_;
      enumName->name = intern("MyBitfield_");
      enumName->size = sizeof(MyBitfield_);
      enumName->variety = TypeVariety_Enum;
      enumName->enumFlags |= EnumFlags_Bitfield;
      

      
      {
         EnumEntryMetadata entry;
         entry.name = intern("MyBitfield_A");
         entry.value = MyBitfield_A;
         enumName->enumEntries.push_back(entry);
      }

      
      {
         EnumEntryMetadata entry;
         entry.name = intern("MyBitfield_B");
         entry.value = MyBitfield_B;
         enumName->enumEntries.push_back(entry);
      }

      
      {
         EnumEntryMetadata entry;
         entry.name = intern("MyBitfield_C");
         entry.value = MyBitfield_C;
         enumName->enumEntries.push_back(entry);
      }

      
   }

   
   
   {
      auto& structName = meta_MyStruct;
      structName->name = intern("MyStruct");
      structName->size = sizeof(MyStruct);
      structName->variety = TypeVariety_Struct;

      structName->funcs.create = [](void* data) {new (data) MyStruct;};
      structName->funcs.destroy = [](void* data) {((MyStruct*)data)->~MyStruct(); };

      
      {
         StructMemberMetadata member;
         member.name = intern("enumTest");
         member.offset = offsetof(MyStruct, enumTest);
         member.type = reflect<MyEnum>();
         member.customUI = customUIRenderer<MyEnum>();
         
         

         structName->structMembers.push_back(member);
      }

      
      {
         StructMemberMetadata member;
         member.name = intern("ints");
         member.offset = offsetof(MyStruct, ints);
         member.type = reflect<Array<int>>();
         member.customUI = customUIRenderer<Array<int>>();
         
         

         structName->structMembers.push_back(member);
      }

      
      {
         StructMemberMetadata member;
         member.name = intern("staticStrings");
         member.offset = offsetof(MyStruct, staticStrings);
         member.type = reflect<std::string>();
         member.customUI = customUIRenderer<std::string>();
         member.flags |= StructMemberFlags_StaticArray;
         member.staticArraySize = 10;
         
         

         structName->structMembers.push_back(member);
      }

      
      {
         StructMemberMetadata member;
         member.name = intern("bitfield");
         member.offset = offsetof(MyStruct, bitfield);
         member.type = reflect<MyBitfield_>();
         member.customUI = customUIRenderer<MyBitfield_>();
         
         

         structName->structMembers.push_back(member);
      }

      
      {
         StructMemberMetadata member;
         member.name = intern("intRange");
         member.offset = offsetof(MyStruct, intRange);
         member.type = reflect<int>();
         member.customUI = customUIRenderer<int>();
         member.ui.min = (float)0;
         member.ui.max = (float)100;
         
         

         structName->structMembers.push_back(member);
      }

      
      {
         StructMemberMetadata member;
         member.name = intern("dragTest");
         member.offset = offsetof(MyStruct, dragTest);
         member.type = reflect<float>();
         member.customUI = customUIRenderer<float>();
         member.ui.min = (float)0;
         member.ui.max = (float)1;
         member.ui.step = (float)0.001;
         
         

         structName->structMembers.push_back(member);
      }

      
      {
         StructMemberMetadata member;
         member.name = intern("readonly");
         member.offset = offsetof(MyStruct, readonly);
         member.type = reflect<std::string>();
         member.customUI = customUIRenderer<std::string>();
         member.flags |= StructMemberFlags_ReadOnly;
         
         

         structName->structMembers.push_back(member);
      }

      
      {
         StructMemberMetadata member;
         member.name = intern("map");
         member.offset = offsetof(MyStruct, map);
         member.type = reflect<std::unordered_map<Symbol*, MyBitfield_>>();
         member.customUI = customUIRenderer<std::unordered_map<Symbol*, MyBitfield_>>();
         
         

         structName->structMembers.push_back(member);
      }

      
      {
         StructMemberMetadata member;
         member.name = intern("color");
         member.offset = offsetof(MyStruct, color);
         member.type = reflect<ColorRGBAf>();
         member.customUI = customUIRenderer<ColorRGBAf>();
         
         

         structName->structMembers.push_back(member);
      }

      
      {
         StructMemberMetadata member;
         member.name = intern("path");
         member.offset = offsetof(MyStruct, path);
         member.type = reflect<std::string>();
         member.customUI = customUIRenderer<std::string>();
         member.flags |= StructMemberFlags_File;
         
         

         structName->structMembers.push_back(member);
      }

      
      {
         StructMemberMetadata member;
         member.name = intern("dataTest");
         member.offset = offsetof(MyStruct, dataTest);
         member.type = reflect<Blob>();
         member.customUI = customUIRenderer<Blob>();
         
         

         structName->structMembers.push_back(member);
      }

      
      {
         StructMemberMetadata member;
         member.name = intern("int2");
         member.offset = offsetof(MyStruct, int2);
         member.type = reflect<Int2>();
         member.customUI = customUIRenderer<Int2>();
         
         

         structName->structMembers.push_back(member);
      }

      
      {
         StructMemberMetadata member;
         member.name = intern("float2");
         member.offset = offsetof(MyStruct, float2);
         member.type = reflect<Float2>();
         member.customUI = customUIRenderer<Float2>();
         
         

         structName->structMembers.push_back(member);
      }

      
   }

      
}