// This code was generated by robots, do not modify
// This is an inline file for use with app

#include "reflection_gen.h"


// MyEnum ----------------------------
TypeMetadata* meta_MyEnum = new TypeMetadata();
template<>
struct Reflector<MyEnum>{
   static TypeMetadata const* type() { return meta_MyEnum; }
};


// MyStruct ----------------------------
TypeMetadata* meta_MyStruct = new TypeMetadata();
template<>
struct Reflector<MyStruct>{
   static TypeMetadata const* type() { return meta_MyStruct; }
};



void app_reflectionStartup_generated(){
   // this should be called automatically by reflectionStartup_generated()
   
   {
      auto& enumName = meta_MyEnum;
      enumName->name = intern("MyEnum");
      enumName->size = sizeof(MyEnum);
      enumName->variety = TypeVariety_Enum;
      

      
      {
         EnumEntryMetadata entry;
         entry.name = intern("MyEnum_A");
         entry.value = MyEnum_A;
         enumName->enumEntries.push_back(entry);
      }

      
      {
         EnumEntryMetadata entry;
         entry.name = intern("MyEnum_B");
         entry.value = MyEnum_B;
         enumName->enumEntries.push_back(entry);
      }

      
      {
         EnumEntryMetadata entry;
         entry.name = intern("MyEnum_C");
         entry.value = MyEnum_C;
         enumName->enumEntries.push_back(entry);
      }

      
      {
         EnumEntryMetadata entry;
         entry.name = intern("MyEnum_D");
         entry.value = MyEnum_D;
         enumName->enumEntries.push_back(entry);
      }

      
      {
         EnumEntryMetadata entry;
         entry.name = intern("MyEnum_E");
         entry.value = MyEnum_E;
         enumName->enumEntries.push_back(entry);
      }

      
      {
         EnumEntryMetadata entry;
         entry.name = intern("MyEnum_F");
         entry.value = MyEnum_F;
         enumName->enumEntries.push_back(entry);
      }

      
   }

   
   
   {
      auto& structName = meta_MyStruct;
      structName->name = intern("MyStruct");
      structName->size = sizeof(MyStruct);
      structName->variety = TypeVariety_Struct;

      structName->funcs.create = [](void* data) {new (data) MyStruct;};
      structName->funcs.destroy = [](void* data) {((MyStruct*)data)->~MyStruct(); };

      
      {
         StructMemberMetadata member;
         member.name = intern("enumTest");
         member.offset = offsetof(MyStruct, enumTest);
         member.type = reflect<MyEnum>();
         
         structName->structMembers.push_back(member);
      }

      
   }

      
}